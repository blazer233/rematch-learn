import { __awaiter, __generator, isListener } from "./util";
import { pluginFactory } from "./pluginFactory.js";
import { dispatchPlugin } from "./dispatchPlugin.js";
import { effectsPlugin } from "./effectsPlugin.js";
import ActionTypes from "./common.js";
import { createStore, compose, applyMiddleware } from "./createStore.js";
import combineReducers from "./combineReducers.js";
import bindActionCreators from "./thunk.js";
import { mergeConfig } from "./merge";
import logger from "redux-logger";
var Redux = Object.freeze({
  __proto__: null,
  __DO_NOT_USE__ActionTypes: ActionTypes,
  applyMiddleware,
  bindActionCreators,
  combineReducers,
  compose,
  createStore,
});
var count = 0;
var corePlugins = [dispatchPlugin, effectsPlugin];
/**
 * Rematch class
 *
 * an instance of Rematch generated by "init"
 */
function Rematch(config) {
  this.plugins = [];
  this.config = { ...config, plugins: config.plugins.concat(corePlugins) };
  this.pluginFactory = pluginFactory(config);
  this.config.plugins.forEach(item =>
    this.plugins.push(this.pluginFactory.create(item))
  );
  this.forEachPlugin("middleware", middleware => {
    this.config.redux.middlewares.push(middleware);
  });
}
Rematch.prototype.forEachPlugin = function (method, fn) {
  this.plugins.forEach(plugin => {
    if (plugin[method]) fn(plugin[method]);
  });
};
//合并插件
Rematch.prototype.getModels = function (models) {
  return Object.keys(models).map(name => ({
    ...models[name],
    reducers: models[name].reducers || {},
    name,
  }));
};
// 将插件添加
Rematch.prototype.addModel = function (model) {
  this.forEachPlugin("onModel", onModel => onModel(model));
};
Rematch.prototype.createRedux = function ({ redux, models }) {
  console.log(redux, models);
  var combineReducers$1 = redux.combineReducers || combineReducers;
  var createStore$1 = redux.createStore || createStore;
  var initialState = redux.initialState ? redux.initialState : {};
  this.reducers = redux.reducers;
  // combine models to generate reducers
  this.mergeReducers = function (nextReducers) {
    if (!nextReducers) nextReducers = {};
    // Object.assign new reducers with existing reducers
    this.reducers = Object.assign(this.reducers, nextReducers, {});
    if (!Object.keys(this.reducers).length) {
      // no reducers, just return state
      return state => state;
    }
    return combineReducers$1(this.reducers);
  };
  this.createModelReducer = function (model) {
    var modelBaseReducer = model.baseReducer;
    var modelReducers = {};
    for (
      var _i = 0, _a = Object.keys(model.reducers || {});
      _i < _a.length;
      _i++
    ) {
      var modelReducer = _a[_i];
      var action = isListener(modelReducer)
        ? modelReducer
        : model.name + "/" + modelReducer;
      modelReducers[action] = model.reducers[modelReducer];
    }
    var combinedReducer = function (state, action) {
      if (state === void 0) {
        state = model.state;
      }
      // handle effects
      if (typeof modelReducers[action.type] === "function") {
        return modelReducers[action.type](state, action.payload, action.meta);
      }
      return state;
    };
    this.reducers[model.name] = !modelBaseReducer
      ? combinedReducer
      : function (state, action) {
          return combinedReducer(modelBaseReducer(state, action), action);
        };
  };
  // initialize model reducers
  for (var _i = 0, models_1 = models; _i < models_1.length; _i++) {
    var model = models_1[_i];
    this.createModelReducer(model);
  }
  this.createRootReducer = function (rootReducers) {
    if (rootReducers === void 0) {
      rootReducers = {};
    }
    console.log(rootReducers);
    var mergedReducers = this.mergeReducers();
    if (Object.keys(rootReducers).length) {
      return function (state, action) {
        var rootReducerAction = rootReducers[action.type];
        if (rootReducers[action.type]) {
          return mergedReducers(rootReducerAction(state, action), action);
        }
        return mergedReducers(state, action);
      };
    }
    return mergedReducers;
  };
  var rootReducer = this.createRootReducer(redux.rootReducers);
  redux.middlewares.push(logger);
  var middlewares = applyMiddleware.apply(Redux, redux.middlewares);
  this.store = createStore$1(rootReducer, initialState, middlewares);
  return this;
};
Rematch.prototype.init = function () {
  this.models = this.getModels(this.config.models) || [];
  this.models.forEach(model => this.addModel(model));
  var redux = this.createRedux({
    redux: this.config.redux,
    models: this.models,
  });
  var rematchStore = Object.assign(
    redux.store,
    { name: this.config.name },
    {
      model: model => {
        this.addModel(model);
        redux.mergeReducers(redux.createModelReducer(model));
        redux.store.dispatch({ type: "@@redux/REPLACE " });
      },
    }
  );
  this.forEachPlugin("onStoreCreated", function (onStoreCreated) {
    var returned = onStoreCreated(rematchStore);
    if (returned) {
      Object.keys(returned || {}).forEach(function (key) {
        rematchStore[key] = returned[key];
      });
    }
  });
  return rematchStore;
};
export const init = initConfig => {
  if (!initConfig) initConfig = {};
  count += 1;
  var name = initConfig.name || count;
  var config = mergeConfig({ ...initConfig, name });
  console.log(initConfig, config);
  return new Rematch(config).init();
};
